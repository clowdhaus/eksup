{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EKS Cluster Upgrade Guidance","text":""},{"location":"#why-is-this-needed","title":"Why Is This Needed","text":"<p>Kubernetes releases a new version approximately every 4 months. Each minor version is supported for 12 months after it's first released by the Kubernetes community, and Amazon EKS supports a Kubernetes version for 14 months once made available. In line with the Kubernetes community support for versions, Amazon EKS is committed to supporting at least four versions of Kubernetes at any given time. This means that Amazon EKS users need to be prepared to upgrade their cluster version(s) at least once a year. However, there are a number of factors that can make each upgrade different and unique that users will need to evaluate prior to each upgrade. Factors that can change between each upgrade cycle include:</p> <ul> <li>New team members who are inexperienced with the upgrade process, and/or prior team members who have experience in cluster upgrades are no longer on the team</li> <li>Different Kubernetes APIs are marked as deprecated or removed from the next release</li> <li>Kubernetes resources that were previously provided by Kubernetes \"in-tree\" are now provided as external resources (i.e - moving Kubernetes in-tree cloud provider code out to their respective standalone projects such as ALB ingress controller \"in-tree\" to the external ALB load balancer controller)</li> <li>Various changes and deprecations in the components used by Kubernetes (i.e - moving from <code>kube-dns</code> to <code>CoreDNS</code>, moving from Docker engine to <code>containerd</code> for container runtime, dropping support for <code>dockershim</code>, etc.)</li> <li>Changes in your applications, your architecture, or the amount of traffic your clusters are handling. Over time, the number of available IPs for the cluster resources may shrink, stateful workloads may have been added to the cluster, etc., and these factors can influence the upgrade process.</li> </ul>"},{"location":"#what-is-eksup","title":"What Is <code>eksup</code>","text":"<p><code>eksup</code> is a CLI that helps users prepare for a cluster upgrade - providing users as much relevant information as possible for their upgrade.</p> <p><code>eksup</code> gives users the ability to analyze their cluster(s) against the next version of Kubernetes, highlighting any findings that may affect the upgrade process. In addition, <code>eksup</code> has the ability to generate a playbook tailored to the cluster analyzed that provides the process for upgrading the cluster including the findings that require remediation. The playbook output allows users to edit the upgrade steps to suit their cluster configuration and business requirements plus capture any specific learnings during the upgrade process. Since most users typically perform upgrades on nonproduction clusters first, any additional steps or call-outs that are discovered during the upgrade process can be captured and used to improve the upgrade process for their production clusters. Users are encouraged to save their playbooks as historical artifacts for future reference to ensure that with each cycle, the team has a better understanding of the upgrade process and more confidence in swiftly working through cluster upgrades before their Kubernetes version support expires.</p>"},{"location":"#what-it-is-not","title":"What It Is NOT","text":"<ul> <li><code>eksup</code> is not a tool that will perform the cluster upgrade. It is assumed that clusters are generally created using an infrastructure as code approach through tools such as Terraform, <code>eksctl</code>, or CloudFormation. Therefore, users are encouraged to use those tools to perform the upgrade to avoid any resource definition conflicts.</li> <li>It does not perform any modifications on the resources it identifies as needing, or recommending, changes. Again, following the approach of infrastructure as code, users are encouraged to make these changes through their normal change control process at the appropriate time in the upgrade process.</li> <li>In the future, <code>eksup</code> may provide functionality to help in converting a Kubernetes manifest definition from one API version to the next. However, this will occur on the users local filesystem and not against a live cluster. <code>eksup</code> will always operate from the perspective of infrastructure as code; any feature requests that support this tenant are encouraged.</li> </ul>"},{"location":"scratch/","title":"Scratch","text":"<p>A check must be able to answer <code>yes</code> to one of the following questions, depending on the type of check:</p> <ul> <li>Required: It will adversely affect the cluster and/or the services/applications running on the cluster during an upgrade</li> <li>Recommended: It *has the potential to affect the cluster and/or the services/applications running on the cluster during an upgrade</li> </ul>"},{"location":"scratch/#todo","title":"\ud83d\udea7 ToDo \ud83d\udea7","text":"<ul> <li>[ ] Add summary at top of results shown to user for stdout and playbook   <pre><code>Checks: 31 (Failed: 14, Excluded: 0, Skipped: 0)\n</code></pre></li> <li>[x] [<code>K8S001</code>] Version skew between control plane and data plane should adhere to skew policy</li> </ul>"},{"location":"scratch/#amazon-eks","title":"Amazon EKS","text":"<ul> <li>[x] [<code>EKS001</code>] There are at least 5 free IPs in control plane subnets</li> <li>[ ] [<code>AWS001</code>] Report on number of free IPs in data plane subnets<ul> <li>TBD: should this be reported per MNG/ASG/profile, as a whole (data plane), or both?</li> </ul> </li> <li>[x] [<code>AWS002</code>] Report on number of free IPs used by the pods when using custom networking</li> <li>[x] [<code>EKS002</code>] Control plane is free of health issues</li> <li>[x] [<code>EKS003</code>] EKS managed node group(s) are free of health issues</li> <li>[x] [<code>EKS004</code>] EKS addon(s) are free of health issues</li> <li>[x] [<code>EKS005</code>] EKS addon version is within supported range; recommend upgrading if target Kubernetes version default addon version is newer</li> <li>[x] [<code>EKS006</code>] EKS managed node group(s): report if the launch template version is not the latest</li> <li>[x] [<code>EKS007</code>] Self-managed node group(s): report if the launch template version is not the latest</li> <li>[ ] Check AWS service limits and utilization for relevant resources</li> <li>Requires premium support https://docs.aws.amazon.com/awssupport/latest/user/service-limits.html</li> <li>[ ] [<code>AWS003</code>] EC2 instance service limits<ul> <li><code>aws support describe-trusted-advisor-check-result --check-id 0Xc6LMYG8P</code></li> </ul> </li> <li>[ ] EBS volume service limits<ul> <li>[ ] [<code>AWS004</code>] GP2 <code>aws support describe-trusted-advisor-check-result --check-id dH7RR0l6J9</code></li> <li>[ ] [<code>AWS005</code>] GP3 <code>aws support describe-trusted-advisor-check-result --check-id dH7RR0l6J3</code></li> </ul> </li> </ul>"},{"location":"scratch/#kubernetes-highly-available","title":"Kubernetes Highly Available","text":"Check Deployment ReplicaSet ReplicationController StatefulSet Job CronJob Daemonset [<code>K8S001</code>] - - - - - - - [<code>K8S002</code>] \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c [<code>K8S003</code>] \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c [<code>K8S004</code>] \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c [<code>K8S005</code>] \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c [<code>K8S006</code>] \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c [<code>K8S007</code>] \u274c \u274c \u274c \u2705 \u274c \u274c \u274c [<code>K8S008</code>] \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 [<code>K8S009</code>] - - - - - - - [<code>K8S010</code>] - - - - - - - <ul> <li>[x] [<code>K8S002</code>] <code>.spec.replicas</code> set &gt;= 3</li> <li>[x] [<code>K8S003</code>] <code>.spec.minReadySeconds</code> set &gt; 0 - https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes</li> <li>[ ] [<code>K8S004</code>] <code>podDisruptionBudgets</code> set &amp; at least one of <code>minAvailable</code> or <code>maxUnavailable</code> is set</li> <li>[ ] [<code>K8S005</code>] Either <code>.spec.affinity.podAntiAffinity</code> or <code>.spec.topologySpreadConstraints</code> set to avoid multiple pods from being scheduled on the same node. https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</li> <li>[ ] Prefer topology hints over affinity <code>Note: Inter-pod affinity and anti-affinity require substantial amount of processing which can slow down scheduling in large clusters significantly. We do not recommend using them in clusters larger than several hundred nodes.</code> https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity</li> <li>[ ] [<code>K8S006</code>] <code>.spec.containers[*].readinessProbe</code> set</li> <li>[ ] <code>.spec.containers[*].livenessProbe</code> , if set, is NOT the same as <code>.spec.containers[*].readinessProbe</code></li> <li>[ ] <code>.spec.containers[*].startupProbe</code> is set if <code>.spec.containers[*].livenessProbe</code> is set</li> <li>[ ] [<code>K8S007</code>] <code>pod.Spec.TerminationGracePeriodSeconds</code> &gt; 0 - The StatefulSet should not specify a pod.Spec.TerminationGracePeriodSeconds of 0 https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees</li> <li>(StatefulSet)</li> </ul>"},{"location":"scratch/#kubernetes-deprecations","title":"Kubernetes Deprecations","text":"<p>Note: the Kubernetes version these apply to will need to be taken into consideration to avoid telling users about checks that do not apply to their version.</p> <ul> <li>[ ] [<code>K8S008</code>] Detect docker socket use (1.24+ affected) https://github.com/aws-containers/kubectl-detector-for-docker-socket</li> <li>[ ] [<code>K8S009</code>] Warn on pod security policy use (deprecated 1.21, removed 1.25) https://kubernetes.io/docs/concepts/security/pod-security-policy/</li> <li>[ ] Advise to switch to pod security admission https://kubernetes.io/docs/concepts/security/pod-security-admission/</li> <li>[ ] [<code>K8S010</code>] In-tree to CSI migration https://kubernetes.io/blog/2021/12/10/storage-in-tree-to-csi-migration-status-update/ ?</li> <li>[ ] The in-tree Amazon EBS storage provisioner is deprecated. If you are upgrading your cluster to version 1.23, then you must first install the Amazon EBS driver before updating your cluster. For more information, see Amazon EBS CSI migration frequently asked questions. If you have pods running on a version 1.22 or earlier cluster, then you must install the Amazon EBS driver before updating your cluster to version 1.23 to avoid service interruption. https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi-migration-faq.html</li> <li>Blog https://aws.amazon.com/blogs/containers/migrating-amazon-eks-clusters-from-gp2-to-gp3-ebs-volumes/</li> </ul>"},{"location":"scratch/#future-considerations","title":"Future Considerations","text":"<ul> <li>[ ] APIs deprecated and/or removed in the next Kubernetes version</li> <li>For now, <code>pluto</code> or <code>kubent</code> are recommended to check for deprecated APIs</li> <li>Add section on how those tools work, what to watch out for (asking the API Server is not trustworthy, scanning manifests directly is the most accurate)</li> <li>Look into using the <code>apiserve_requested_deprecated_apis</code> metric to detect usage of deprecated APIs<ul> <li>https://kubernetes.io/blog/2020/09/03/warnings/</li> <li>https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1693-warnings</li> <li>https://github.com/kube-rs/kube/issues/492 for implementation</li> </ul> </li> <li>[ ] Add image and chart for running <code>eksup</code> on the cluster in a continuous fashion (CronJob)</li> <li>Send results to a central location like S3 for centralized aggregation and reporting across a fleet of clusters</li> <li>[ ] Add support to output results in JSON and CSV formats</li> <li>Multi-cluster scenario - all clusters emitting data back to central location to report on which clusters need components to be upgraded/modified</li> <li>Can utilize an Athena table to aggregate and summarize data</li> <li>[ ] Configuration file to allow users more control over what checks they want to opt in/out of, the values of those checks, etc.</li> <li>[ ] Progress indicator https://github.com/console-rs/indicatif</li> <li>[ ] Ability to convert from one resource API version to another (where possible)</li> <li><code>migrate</code> or <code>transform</code></li> <li>Given a manifest, convert the manifest to the next, stable API version. Some resources only need the API version changed, others will require the schema to be modified to match the new API version</li> <li>[ ] Add snippets/information for commonly used provisioning tools to explain how those fit into the guidance</li> <li><code>terraform-aws-eks</code>/<code>eksctl</code> - how to upgrade a cluster with these tools, what will they do for the user (ensure addon versions are aligned with the Kubernetes version, the ordering of upgrade steps, etc.)</li> <li>[ ] Configure output levels</li> <li><code>--quiet</code> - suppress all output</li> <li>(default, no flags) - show failed checks on hard requirements</li> <li><code>--warn</code> - in addition to failed, show warnings (low number of IPs available for nodes/pods, addon version older than current default, etc.)</li> <li><code>--info</code> - in addition to failed and warnings, show informational notices (number of IPs available for nodes/pods, addon version relative to current default and latest, etc.)</li> </ul>"},{"location":"scratch/#notes","title":"Notes","text":"<ul> <li>Prefer topology hints over affinity for larger clusters</li> <li>Inter-pod affinity and anti-affinity     &gt; Note: Inter-pod affinity and anti-affinity require substantial amount of processing which can slow down scheduling in large clusters significantly. We do not recommend using them in clusters larger than several hundred nodes.</li> </ul>"},{"location":"scratch/#questions","title":"Questions","text":"<ul> <li>What is the guidance for batch workloads?</li> <li>Recommend creating a maintenance window where workloads should avoid being scheduled?</li> <li><code>JobFailurePolicy</code> coming in in 1.26 https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-failure-policy</li> <li>What is the recommended way to manage the lifecycle of Fargate pods?</li> <li>After the control plane Kubernetes version has been upgraded, what is the best approach to \"roll\" the pods in order to pull fresh pods/nodes with the new K8s version?</li> <li>Use a mutating webhook to inject <code>nodeSelector: failure-domain.beta.kubernetes.io/zone: &lt;AZ&gt;</code> into pods created to distribute across the AZs. (EKS Fargate does not natively do this today - see https://github.com/aws/containers-roadmap/issues/824)</li> <li>What is the churn calculation for updating node groups?</li> <li>What is the surge calculation - I thought I saw it was <code>2 * max(min-size, desired-size)</code> somewhere?</li> <li>For EKS MNG, the surge limit is capped at 100 nodes - should this be applied to self-managed node groups as well, and if so, how?</li> <li>This is important for:<ul> <li>Do users have enough resources at their disposal before the start their upgrade or do they need to request resource limit increases (EC2s)?</li> <li>How does the number of available IPs affect this process? If a customer knows they only have <code>x</code> available IPs in the data plane (say 100), can we provide a calculation that helps them configure their update settings to avoid errors and exhausting IPs while upgrading?</li> <li>How long will the upgrade take users?</li> <li>How can users influence the amount of churn - why should they, what recommendations or guidance do we have?</li> </ul> </li> <li>Do we have different guidance for large clusters?</li> <li>See note on Inter-pod affinity and anti-affinity</li> </ul>"},{"location":"scratch/#kubernetes-upcoming-features","title":"Kubernetes Upcoming Features","text":"<p>Relevant features that are coming in future releases of Kubernetes. A feature is \"relevant\" in in this context if it is something that would be checked and reported on by <code>eksup</code> to aid in upgrades:</p> <ul> <li><code>.spec.updateStrategy.rollingUpdate.maxUnavailable</code> for StatefulSets <code>Kubernetes v1.24 [alpha]</code></li> <li>Recommend that a value is set on all StatefulSets</li> <li><code>PodDisruptionCondition</code> for PodDisruptionBudgets <code>Kubernetes v1.26 [beta]</code></li> <li>See recommendation below for <code>podFailurePolicy</code></li> <li><code>.spec.podFailurePolicy</code> for Jobs/CronJobs <code>Kubernetes v1.26 [beta]</code></li> <li>Recommend to <code>Ignore</code> conditions caused by preemption, API-initiated eviction, or taint-based eviction so that upgrade type evictions do not count against <code>.spec.backoffLimit</code> and the jobs will be re-tried. Note - <code>.spec.restartPolicy</code> will need to be set to <code>Never</code> and <code>PodDisruptionCondition</code> must be set for PodDisruptionBudgets</li> </ul>"},{"location":"scratch/#misc","title":"Misc","text":"<ul> <li>Update strategies should be reviewed for 3rd party addons. For example, once the cluster is upgrade, users should review the other addons/controllers/operators running on the cluster and update if necessary. While not directly tied to the cluster upgrade itself, its important to at least inform that this is a recommended practice for users to follow to avoid downtimes when upgrading those components following a cluster upgrade.</li> <li><code>.spec.strategy.type</code> != <code>Recreate</code> - https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment<ul> <li>(Deployment, ReplicaSet) - excludes ReplicationController which recommends blue/green upgrade</li> <li>[ ] <code>.spec.strategy.rollingUpdate.maxUnavailable</code> is set (Recommended)</li> <li>[ ] <code>.spec.strategy.rollingUpdate.maxSurge</code> is set (Recommended)</li> </ul> </li> <li>[ ] <code>.spec.updateStrategy.type</code> != <code>OnDelete</code> - https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#rolling-updates<ul> <li>(StatefulSet)</li> </ul> </li> </ul>"},{"location":"scratch/#data-plane-pre-upgrade","title":"Data Plane Pre-Upgrade","text":"<ul> <li> <p>We strongly recommend that you have readiness and liveness probes configured before upgrading the data plane. This ensures that your pods register as ready/healthy at the appropriate time during an upgrade.</p> <ul> <li>For stateful workloads<ul> <li>\u2139\ufe0f Exploring Upgrade Strategies for Stateful Sets in Kubernetes</li> <li>\u26a0\ufe0f TODO - what guidance for cluster backup before upgrade<ul> <li>Velero</li> <li>Portworx</li> <li>1.24+ only - maximum unavailable pods</li> </ul> </li> <li>If your stateful set does not require unique ordering, typically associated with processes that utilize leader election, switching to a <code>parallel</code> strategy for <code>podManagementPolicy</code> will speed up your scale up/down time as well as reduce the time needed to upgrade your cluster.</li> </ul> </li> </ul> </li> <li> <p>If you are running a critical application on a Karpenter-provisioned node, such as a long running batch job or stateful application, and the node\u2019s TTL has expired, the application will be interrupted when the instance is terminated. By adding a karpenter.sh/do-not-evict annotation to the pod, you are instructing Karpenter to preserve the node until the Pod is terminated or the do-not-evict annotation is removed. See Deprovisioning documentation for further information.</p> </li> </ul>"},{"location":"design/overview/","title":"Overview","text":""},{"location":"design/overview/#goals","title":"Goals","text":"<p>There is only one goal:</p> <p>Empower users to routinely upgrade their EKS cluster(s) while avoiding downtime and/or disruption.</p> <p>To aid in that goal, the following are supporting goals or tenants:</p> <ol> <li>Intended for use on Amazon EKS clusters; there are no guarantees that this CLI will or will not work on other Kubernetes clusters at this time. The CLI will focus on EKS to avoid the need to support multiple Kubernetes distributions and their associated cloud controller resources and instead focus on the aspects that are specific to EKS and how it manages the Kubernetes experience for users. The CLI should offer native support for:</li> <li>Amazon EKS, Amazon EKS on Outposts (local and extended clusters), and [Not yet supported] EKS-A (EKS Anywhere)</li> <li>Amazon EKS managed node groups, self-managed node groups, and Amazon EKS Fargate profiles</li> <li>EKS addons</li> <li>It is designed to produce the least amount of load on the API Server when discovering and analyzing cluster resources. However, this can have some tradeoffs in terms of accuracy and completeness of the information provided to the user; see goal #3 for more information on this tradeoff.</li> <li>It should provide as much relevant information as possible to the user regarding the state of the cluster prior to upgrading. This includes scoping the information provided to the user to only that which is relevant for upgrading from their current Kubernetes version to the intended target Kubernetes version. A more complete analysis that exhaustively searches ALL Kubernetes resources (i.e. - all pods) will produce more load on the API Server especially as the number of resources in the cluster increases. This is a tradeoff that the CLI will make in order to provide the user with the most relevant information for upgrading: the default mode will use a \"shallow\" search by default, analyzing the higher level constructs such as Deployments, StatefulSets, DaemonSets, etc. This makes the assumption that all pods created in the cluster are created by a higher level construct and therefore only analyzing those resources will be sufficient while reducing the amount of load on the API Server during analysis. [Not yet implemented] The user will have the option to choose to perform a more exhaustive search of all pods in the cluster by using the <code>--deep</code> flag. This will produce more load on the API Server and take longer to complete, but will provide the user with a more complete analysis of the cluster. The exhaustive analysis should be used when the user is not sure if all pods in the cluster are created by a higher level construct.</li> <li>It should support the following use cases:</li> <li>A one-off analysis to create a report of the cluster state prior to upgrading along with steps to take to upgrade the cluster (i.e. - analyze the cluster and generate an upgrade playbook).</li> <li>A one-off analysis to report on the state of the cluster for potential issues and/or recommendations prior to upgrading. This is generally a CLI invocation that prints the analysis to the console (stdout) and exits.</li> <li>[Not yet implemented] Continuous analysis of the cluster state for potential issues and/or recommendations that runs from within the cluster that is being reported on. Results can be sent to stdout where they can be picked up from a log aggregator or sent to a remote location, such as Amazon S3, where they can be analyzed and acted upon. This process supports n-number of clusters across m-number of accounts to better aid in multi-cluster management as well as alerting to ensure enough advance notice is given for users to prepare and schedule the pending upgrade before end of support is reached.</li> </ol>"},{"location":"design/overview/#architecture","title":"Architecture","text":""},{"location":"design/overview/#high-level-diagram","title":"High Level Diagram","text":""},{"location":"process/","title":"Getting Started","text":""},{"location":"process/#preface","title":"Preface","text":"<ul> <li>Unless otherwise stated, the phrase <code>Amazon EKS cluster</code> or just <code>cluster</code> throughout the documentation typically refers to the control plane.</li> <li>In-place cluster upgrades can only be upgraded to the next incremental minor version. For example, you can upgrade from Kubernetes version <code>1.20</code> to <code>1.21</code>, but not from <code>1.20</code> to <code>1.22</code>.</li> <li>Reverting an upgrade, or downgrading the Kubernetes version of a cluster, is not supported. If you upgrade your cluster to a newer Kubernetes version and then want to revert to the previous version, you must create a new,separate cluster and migrate your workloads.</li> <li>If the Amazon EKS cluster primary security group has been deleted, the only course of action to upgrade is to create a new, separate cluster and migrate your workloads.</li> <li>Generally speaking, how well your cluster is configured from a high-availability perspective will determine how well your cluster handles the upgrade process. Ensuring that you have properly configured pod disruption budgets, multiple replicas specified in your deployments and statefulsets, properly configured readiness probes, etc., will help to mitigate potential disruptions or downtime during an upgrade. You can read more about EKS best practices for reliability here.</li> </ul>"},{"location":"process/#terminology","title":"Terminology","text":"<ul> <li>In-place upgrade: the process of upgrading the associated resource without re-creation. An in-place cluster upgrade means the Amazon EKS cluster is updated while it continues running and serving traffic and it will retain all of its unique attributes such as endpoint, OIDC thumbprints, etc. An in-place nodegroup upgrade consists of upgrading the underlying EC2 instances within the nodegroup without modifying the nodegroup itself. Typically this is performed by providing a new launch template version that contains the new/updated AMI to the nodegroup which will trigger the nodegroup to replace the EC2 instances with new instances to match the updated launch template. In-place upgrades generally use fewer resources than blue/green upgrades, and are typically easier to perform. A downside to an in-place upgrade is the inability to rollback to the prior configuration in some instances, or a longer time to complete the rollback to a prior configuration.</li> <li>Blue/green upgrade: an upgrade strategy where a second resource (green) is created alongside the current resource (blue). Once the new, second (green) resource is ready, workloads and traffic are shifted from the current resource (blue) over to the new, second (green) resource. Once the workloads and traffic have been shifted over, the current resource (blue) is deleted. Blue/green upgrades allow for better risk mitigation during upgrades, especially when there are substantial changes made in the upgrade since the new, second (green) resource can be tested and validate out of band without disrupting workloads or traffic. Only once the new, second (green) resource has been validated should the workload and traffic be shifted over. In addition, if any unforeseen issues do arise once workloads and traffic are on the new, second (green) resource, rollbacks are generally quick and easy to perform since the prior (blue) resource is still available. A downside to a blue/green upgrade is the additional resources required to create the second resource (green) and the additional time required to perform the upgrade. It can take quite a bit more effort to architect and orchestrate blue/green upgrades but the benefits can be well worth it. You can utilize the blue/green upgrade strategy for the entire cluster as well as for nodegroups. See below for an overview on the process of performing a blue/green upgrade on a nodegroup.</li> </ul>"},{"location":"process/#overview","title":"Overview","text":"<p>A high-level overview of the process for upgrading an Amazon EKS cluster in-place consists of:</p> <ol> <li>Check for things that will affect the control plane upgrade.<ul> <li>This includes checking for any deprecated or removed Kubernetes API objects, ensuring there are at least 5 available IP addresses in the subnets used by the control plane, ensuring the version skew between the control plane and the data plane is within the supported range, etc.</li> </ul> </li> <li>Upgrade the control plane to the next incremental minor version of Kubernetes<ul> <li>This process will take approximately 15 minutes to complete. Even though Amazon EKS runs a highly available control plane, you might experience minor service interruptions during an update. For example, assume that you attempt to connect to an API server around when it's terminated and replaced by a new API server that's running the new version of Kubernetes. You might experience API call errors or connectivity issues. If this happens, retry your API operations until they succeed.</li> </ul> </li> <li>Check for things that will affect the data plane upgrade.<ul> <li>This includes checking for any reported health issues on the nodegroups, ensuring there are enough available IPs to perform the upgrade, ensuring the applications running on the data plane are configured for high availability using pod disruption budgets, readiness probes, topology spread constraints, etc.</li> </ul> </li> <li>Update the data plane to match the new control plane Kubernetes version<ul> <li>Update nodegroups to roll out new AMIs that match the new control plane Kubernetes version; cordon and drain Fargate nodes to have them replaced with new nodes that match the new control plane Kubernetes version</li> </ul> </li> <li>Check for any reported health issues on the EKS addons</li> <li>Update the EKS addons<ul> <li>Ensure the addons are using a version within the supported range for the new control plane Kubernetes version; ideally, use the default version for the new control plane Kubernetes version</li> </ul> </li> <li>Update applications running on the cluster<ul> <li>Some application such as <code>cluster-autoscaler</code>, have a versioning scheme that aligns with the Kubernetes version of the cluster they are running on. This means that once the control plane and data plane components have been updated, these applications should be updated to match as well</li> </ul> </li> <li>Update any clients that interact with the cluster<ul> <li>This includes updating the <code>kubectl</code> client to match the new control plane Kubernetes version</li> </ul> </li> </ol> <p>This is just a brief overview of the general process for upgrading an Amazon EKS cluster in-place. There are a number of finer details that need to be checked and considered on a per-upgrade basis to ensure the upgrade is successful. This is why <code>eksup</code> was created - to help surface that information to users and provide guidance on the process to upgrade their cluster.</p>"},{"location":"process/#symbol-table","title":"Symbol Table","text":"Symbol Description \u2139\ufe0f Informational - users are encouraged to familiarize themselves with the information but no action is required to upgrade \u26a0\ufe0f Recommended - users are encouraged to evaluate the recommendation and determine if it is applicable and whether or not to act upon that recommendation. Not remediating the finding does not prevent the upgrade from occurring. \u274c Required - users must remediate the finding prior to upgrading to be able to perform the upgrade and avoid downtime or disruption"},{"location":"process/checks/","title":"Checks","text":"<p>If a check fails, it is reported as a finding. Each check will have a remediation type - either recommended or required. A recommended remediation is one that is recommended to be performed, but is not required to be performed.</p> <ul> <li>\u26a0\ufe0f Recommended: A finding that users are encouraged to evaluate the recommendation and determine if it is applicable and whether or not to act upon that recommendation. Not remediating the finding does not prevent the upgrade from occurring.</li> <li>\u274c Required: A finding that requires remediation prior to upgrading to be able to perform the upgrade and avoid downtime or disruption</li> </ul> <p>See the symbol table for further details on the symbols used throughout the documentation.</p>"},{"location":"process/checks/#amazon","title":"Amazon","text":"<p>Checks that are not specific to Amazon EKS or Kubernetes</p>"},{"location":"process/checks/#aws001","title":"AWS001","text":"<p>\ud83d\udea7 Not yet implemented</p> <p>\u26a0\ufe0f Remediation recommended</p> <p>There is a sufficient quantity of IPs available for the nodes to support the upgrade.</p> <p>If custom networking is enabled, the results represent the number of IPs available in the subnets used by the EC2 instances. Otherwise, the results represent the number of IPs available in the subnets used by both the EC2 instances and the pods.</p>"},{"location":"process/checks/#aws002","title":"AWS002","text":"<p>\u26a0\ufe0f Remediation recommended</p> <p>There is a sufficient quantity of IPs available for the pods to support the upgrade.</p> <p>This check is used when custom networking is enabled since the IPs used by pods are coming from subnets different from those used by the EC2 instances themselves.</p>"},{"location":"process/checks/#aws003","title":"AWS003","text":"<p>\ud83d\udea7 Not yet implemented</p> <p>EC2 instance service limits</p>"},{"location":"process/checks/#aws004","title":"AWS004","text":"<p>\ud83d\udea7 Not yet implemented</p> <p>EBS GP2 volume service limits</p>"},{"location":"process/checks/#aws005","title":"AWS005","text":"<p>\ud83d\udea7 Not yet implemented</p> <p>EBS GP3 volume service limits</p>"},{"location":"process/checks/#amazon-eks","title":"Amazon EKS","text":"<p>Checks that are specific to Amazon EKS</p>"},{"location":"process/checks/#eks001","title":"EKS001","text":"<p>\u274c Remediation required</p> <p>There are at least 5 available IPs for the control plane to upgrade; required for cross account ENI creation.</p>"},{"location":"process/checks/#eks002","title":"EKS002","text":"<p>\u274c Remediation required</p> <p>Control plane does not have any reported health issues.</p>"},{"location":"process/checks/#eks003","title":"EKS003","text":"<p>\u274c Remediation required</p> <p>EKS managed nodegroup does not have any reported health issues.</p> <p>This does not include self-managed nodegroups or Fargate profiles; those are not currently supported by the AWS API to report health issues.</p>"},{"location":"process/checks/#eks004","title":"EKS004","text":"<p>\u274c Remediation required</p> <p>EKS addon does not have any reported health issues.</p>"},{"location":"process/checks/#eks005","title":"EKS005","text":"<p>\u274c Remediation required</p> <p>EKS addon version is within the supported range.</p> <p>The addon must be updated to a version that is supported by the target Kubernetes version prior to upgrading.</p> <p>\u26a0\ufe0f Remediation recommended</p> <p>The target Kubernetes version default addon version is newer than the current addon version.</p> <p>For example, if the default addon version of CoreDNS for Kubernetes <code>v1.24</code> is <code>v1.8.7-eksbuild.3</code> and the current addon version is <code>v1.8.4-eksbuild.2</code>, while the current version is supported on Kubernetes <code>v1.24</code>, its recommended to update the addon to <code>v1.8.7-eksbuild.3</code> during the upgrade.</p>"},{"location":"process/checks/#eks006","title":"EKS006","text":"<p>\u26a0\ufe0f Remediation recommended</p> <p>EKS managed nodegroup are using the latest launch template version and there are no pending updates for the nodegroup.</p> <p>Users are encourage to evaluate if remediation is warranted or not and whether to update to the latest launch template version prior to upgrading. If there are pending updates, this could potentially introduce additional changes to the nodegroup during the upgrade.</p>"},{"location":"process/checks/#eks007","title":"EKS007","text":"<p>\u26a0\ufe0f Remediation recommended</p> <p>Self-managed nodegroup are using the latest launch template version and there are no pending updates for the nodegroup.</p> <p>Users are encourage to evaluate if remediation is warranted or not and whether to update to the latest launch template version prior to upgrading. If there are pending updates, this could potentially introduce additional changes to the nodegroup during the upgrade.</p>"},{"location":"process/checks/#kubernetes","title":"Kubernetes","text":"<p>Checks that are specific to Kubernetes, regardless of the underlying platform provider.</p> <p>Table below shows the checks that are applicable, or not, to the respective Kubernetes resource.</p> Check Deployment ReplicaSet ReplicationController StatefulSet Job CronJob Daemonset <code>K8S001</code> \udb40\udc2d\u2796 \u2796 \u2796 \u2796 \u2796 \u2796 \u2796 <code>K8S002</code> \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c <code>K8S003</code> \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c <code>K8S004</code> \u2705 \u2705 \u274c \u2705 \u274c \u274c \u274c <code>K8S005</code> \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c <code>K8S006</code> \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c <code>K8S007</code> \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c <code>K8S008</code> \u274c \u274c \u274c \u2705 \u274c \u274c \u274c <code>K8S009</code> \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <code>K8S010</code> \u2796 \u2796 \u2796 \u2796 \u2796 \u2796 \u2796 <code>K8S011</code> \u2796 \u2796 \u2796 \u2796 \u2796 \u2796 \u2796"},{"location":"process/checks/#k8s001","title":"K8S001","text":"<p>\u274c Remediation required</p> <p>The version skew between the control plane (API Server) and the data plane (kubelet) violates the Kubernetes version skew policy, or will violate the version skew policy after the control plane has been upgraded.</p> <p>The data plane nodes must be upgraded to at least within 1 minor version of the control plane version in order to stay within the version skew policy through the upgrade; it is recommended to upgrade the data plane nodes to the same version as the control plane.</p> <p>\u26a0\ufe0f Remediation recommended</p> <p>There is a version skew between the control plane (API Server) and the data plane (kubelet).</p> <p>While Kubernetes does support a version skew of n-2 between the API Server and kubelet, it is recommended to upgrade the data plane nodes to the same version as the control plane.</p> <p>Kubernetes version skew policy</p>"},{"location":"process/checks/#k8s002","title":"K8S002","text":"<p>\u274c Remediation required</p> <p>There are at least 3 replicas specified for the resource.</p> <pre><code>---\nspec:\nreplicas: 3 # &gt;= 3\n</code></pre> <p>Multiple replicas, along with the use of <code>PodDisruptionBudget</code>, are required to ensure high availability during the upgrade.</p> <p>EKS Best Practices - Reliability</p>"},{"location":"process/checks/#k8s003","title":"K8S003","text":"<p>\u274c Remediation required</p> <p><code>minReadySeconds</code> has been set to a value greater than 0 seconds for <code>StatefulSet</code></p> <p>You can read more about why this is necessary for <code>StatefulSet</code> here</p> <p>\u26a0\ufe0f Remediation recommended</p> <p><code>minReadySeconds</code> has been set to a value greater than 0 seconds for <code>Deployment</code>, <code>ReplicaSet</code>, <code>ReplicationController</code></p>"},{"location":"process/checks/#k8s004","title":"K8S004","text":"<p>\ud83d\udea7 Not yet implemented</p> <p>\u274c Remediation required</p> <p>At least one <code>podDisruptionBudget</code> covers the workload, and at least one of <code>minAvailable</code> or <code>maxUnavailable</code> is set</p> <p>The Kubernetes eviction API is the preferred method for draining nodes for replacement during an upgrade. The eviction API respects <code>PodDisruptionBudget</code> and will not evict pods that would violate the <code>PodDisruptionBudget</code> to ensure application availability, when specified.</p>"},{"location":"process/checks/#k8s005","title":"K8S005","text":"<p>\u274c Remediation required</p> <p>Either <code>.spec.affinity.podAntiAffinity</code> or <code>.spec.topologySpreadConstraints</code> is set to avoid multiple pods from the same workload from being scheduled on the same node.</p> <p><code>topologySpreadConstraints</code> are preferred over affinity, especially for larger clusters:</p> <ul> <li> <p>Inter-pod affinity and anti-affinity</p> <p>Note: Inter-pod affinity and anti-affinity require substantial amount of processing which can slow down scheduling in large clusters significantly. We do not recommend using them in clusters larger than several hundred nodes.</p> </li> </ul> <p>Types of inter-pod affinity and anti-affinity</p> <p>Pod Topology Spread Constraints</p>"},{"location":"process/checks/#k8s006","title":"K8S006","text":"<p>A <code>readinessProbe</code> must be set to ensure traffic is not sent to pods before they are ready following their re-deployment from a node replacement.</p>"},{"location":"process/checks/#k8s007","title":"K8S007","text":"<p>\u274c Remediation required</p> <p>The <code>StatefulSet</code> should not specify a <code>TerminationGracePeriodSeconds</code> of 0</p> <ul> <li> <p>Deployment and Scaling Guarantees</p> <p>The StatefulSet should not specify a pod.Spec.TerminationGracePeriodSeconds of 0. This practice is unsafe and strongly discouraged. For further explanation, please refer to force deleting StatefulSet Pods.</p> </li> </ul> <p>Force Delete StatefulSet Pods</p>"},{"location":"process/checks/#k8s008","title":"K8S008","text":"<p>Pod volumes should not mount the <code>docker.sock</code> file with the removal of the Dockershim starting in Kubernetes <code>v1.24</code></p> <p>\u274c Remediation required</p> <p>For clusters on Kubernetes <code>v1.23</code></p> <p>\u26a0\ufe0f Remediation recommended</p> <p>For clusters on Kubernetes &lt;<code>v1.22</code></p> <p>Dockershim Removal FAQ</p> <p>Detector for Docker Socket (DDS)</p>"},{"location":"process/checks/#k8s009","title":"K8S009","text":"<p>The pod security policy resource has been removed started in Kubernetes <code>v1.25</code></p> <p>\u274c Remediation required</p> <p>For clusters on Kubernetes <code>v1.24</code></p> <p>\u26a0\ufe0f Remediation recommended</p> <p>For clusters on Kubernetes &lt;<code>v1.23</code></p> <p>Migrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller</p> <p>PodSecurityPolicy Deprecation: Past, Present, and Future</p>"},{"location":"process/checks/#k8s010","title":"K8S010","text":"<p>\ud83d\udea7 Not yet implemented</p> <p>The in-tree Amazon EBS storage provisioner is deprecated. If you are upgrading your cluster to version <code>v1.23</code>, then you must first install the Amazon EBS driver before updating your cluster. For more information, see Amazon EBS CSI migration frequently asked questions.</p> <p>\u274c Remediation required</p> <p>For clusters on Kubernetes <code>v1.22</code></p> <p>\u26a0\ufe0f Remediation recommended</p> <p>For clusters on Kubernetes &lt;<code>v1.21</code></p> <p>Amazon EBS CSI migration frequently asked questions</p> <p>Kubernetes In-Tree to CSI Volume Migration Status Update</p>"},{"location":"process/commands/","title":"Commands","text":""},{"location":"process/commands/#commands","title":"Commands","text":"<pre><code>A CLI to aid in upgrading Amazon EKS clusters\n\nUsage: eksup &lt;COMMAND&gt;\n\nCommands:\n  analyze  Analyze an Amazon EKS cluster for potential upgrade issues\n  create   Create artifacts using the analysis data\n  help     Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre>"},{"location":"process/commands/#analyze","title":"Analyze","text":"<p>Analyze cluster for any potential issues to remediate prior to upgrade.</p> <pre><code>Analyze an Amazon EKS cluster for potential upgrade issues\n\nUsage: eksup analyze [OPTIONS] --cluster &lt;CLUSTER&gt;\n\nOptions:\n  -c, --cluster &lt;CLUSTER&gt;\n          The name of the cluster to analyze\n\n  -r, --region &lt;REGION&gt;\n          The AWS region where the cluster is provisioned\n\n  -f, --format &lt;FORMAT&gt;\n          [default: text]\n\n          Possible values:\n          - json: JSON format used for logging or writing to a *.json file\n          - text: Text format used for writing to stdout\n\n  -o, --output &lt;OUTPUT&gt;\n          Write to file instead of stdout\n\n      --ignore-recommended\n          Exclude recommendations from the output\n\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n</code></pre> <p>Show result as plaintext via stdout:</p> <pre><code>eksup analyze --cluster &lt;cluster&gt; --region &lt;region&gt;\n</code></pre> <p>Show result as JSON via stdout:</p> <pre><code>eksup analyze --cluster &lt;cluster&gt; --region &lt;region&gt; --format json\n</code></pre> <p>Save result as plaintext to file:</p> <pre><code>eksup analyze --cluster &lt;cluster&gt; --region &lt;region&gt; --output analysis.txt\n</code></pre> <p>Save result as JSON to S3, ignoring recommendations:</p> <pre><code>eksup analyze --cluster &lt;cluster&gt; --region &lt;region&gt; \\\n--format json --output s3://&lt;bucket&gt;/&lt;filename&gt; --ignore-recommended\n</code></pre>"},{"location":"process/commands/#create","title":"Create","text":"<p>Create a playbook with analysis findings to guide users through pre-upgrade, upgrade, and post-upgrade process.</p> <p>This CLI produces a cluster upgrade playbook that attempts to:</p> <ul> <li>Educate users on the overall process of upgrading an Amazon EKS cluster (order of operations, which parts AWS manages and which parts are the user's responsibility, etc.)</li> <li>Provide one approach as the basis for upgrading a cluster that users can modify/customize to suit their cluster configuration/architecture and business requirements</li> <li>Provide recommendations on what to check for and precautions to consider before upgrading, how to perform the cluster upgrade, and considerations for configuring your cluster and/or applications to minimize risk and disruption during the upgrade process</li> </ul> <pre><code>Create a playbook for upgrading an Amazon EKS cluster\n\nUsage: eksup create playbook [OPTIONS] --cluster &lt;CLUSTER&gt;\n\nOptions:\n  -c, --cluster &lt;CLUSTER&gt;    The name of the cluster to analyze\n  -r, --region &lt;REGION&gt;      The AWS region where the cluster is provisioned\n  -f, --filename &lt;FILENAME&gt;  Name of the playbook saved locally\n      --ignore-recommended   Exclude recommendations from the output\n  -h, --help                 Print help\n  -V, --version              Print version\n</code></pre> <p>Create playbook and save locally:</p> <pre><code>eksup create playbook --cluster &lt;cluster&gt; --region &lt;region&gt;\n</code></pre> <p>Create playbook and save locally, ignoring recommendations:</p> <pre><code>eksup create playbook --cluster &lt;cluster&gt; --region &lt;region&gt; --ignore-recommended\n</code></pre> <p>See examples for examples of the playbook output.</p>"}]}